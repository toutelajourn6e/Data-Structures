# Binary Search Tree
![bst-21](https://github.com/toutelajourn6e/Data_Structures/assets/118504009/033fdbfe-e16d-4873-9423-e90efd063f3a)

### 이진 탐색 트리의 특징
1. 노드에 저장된 키는 유일하다.
2. 모든 노드의 최대 자식 노드 갯수는 2개이다.
3. 모든 노드의 왼쪽 서브트리는 해당 노드의 값보다 작은 값들만 가지고, 모든 노드의 오른쪽 서브트리는 해당 노드보다 큰 값들만 가진다.
4. 이진 탐색 트리의 최솟값은 트리의 가장 왼쪽에 있고 최댓값은 트리의 가장 오른쪽에 있다.<br>
- - -
### 트리의 순회방법
1. 전위 순회: 현재 노드 방문 → 재귀적으로 왼쪽 서브트리 순회 → 재귀적으로 오른쪽 서브트리 순회
2. 중위 순회: 재귀적으로 왼쪽 서브트리 순회 → 현재 노드 방문 → 재귀적으로 오른쪽 서브트리 순회
3. 후위 순회: 재귀적으로 왼쪽 서브트리 순회 → 재귀적으로 오른쪽 서브트리 순회 → 현재 노드 방문
- - -
###### 선임자(Predecessor) : 자신보다 값이 작은 노드들 중에서 가장 큰 값을 가진 노드
###### 후임자(Successor) : 자신보다 값이 큰 노드들 중에서 가장 작은 값을 가진 노드
###### 삭제 연산에서 후임자나 선임자 둘 중 하나가 필요하다. 이번 구현에서는 후임자를 사용
- - -
### 이진 탐색 트리의 장단점
* 삽입 삭제가 유연하다.
* 평균적인 상황에서 삽입 삭제 탐색이 빠르다.
* 여러가지 방법으로 순회가 가능하다.
* **트리가 구조적으로 편향되면 삽입 삭제 검색 등의 연산 수행시간이 악화된다. 이 문제를 해결하기 위해 스스로 균형을 잡는 균형 이진 탐색 트리가 사용된다. (AVL, RB 등)**
<br>

## ADT
* insert : 트리에 노드 삽입
* search : 트리에 특정 값을 가진 노드가 있는지 확인
* delete : 트리의 노드 삭제
  - 노드의 자식이 0개 -> 바로 삭제
  - 노드의 자식이 1개 -> 삭제될 노드의 부모 노드가 자식 노드를 가리킴
  - 노드의 자식이 2개 -> 먼저 후임자/선임자를 찾고,
    1. 이때 후임자/선임자의 자식이 1개라면, 후임자/선임자의 부모 노드가 자식 노드를 가리키고 삭제될 노드의 자리로 후임자/선임자 이동
    2. 후임자/선임자의 자식이 0개라면, 삭제될 노드의 자리로 후임자/선임자 바로 이동
* preorder : 트리 전위 순회
* inorder : 트리 중위 순회
* postorder : 트리 후위 순회


## Time Complexity

|      연산       | Average | Worst |
|:-------------:|:------:|:------:|
|      insert       |  O(logN)  | O(N) |
|      search       |  O(logN)  | O(N) |
|      delete       |  O(logN)  | O(N) |
